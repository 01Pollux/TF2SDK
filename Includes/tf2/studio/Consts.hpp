#pragma once

#include <tf2/config.hpp>

TF2_NAMESPACE_BEGIN(::Const)

static constexpr uint32_t StudioVersion = 48;

static constexpr uint32_t StudioSequenceActivity_LookupAreSlow = 0;
static constexpr uint32_t StudioSequenceActivity_LazyInit = 1;

struct Quaternion48
{
	unsigned short x : 16;
	unsigned short y : 16;
	unsigned short z : 15;
	unsigned short wneg : 1;
};

struct Quaternion64
{
	unsigned __int64 x : 21;
	unsigned __int64 y : 21;
	unsigned __int64 z : 21;
	unsigned __int64 wneg : 1;
};

static constexpr uint32_t MaxStudio_Triangles	= 65'536;
static constexpr uint32_t MaxStudio_Overts		= 65'536;
// max number of verts that can be flexed per mesh.  TODO: tune this
static constexpr uint32_t MaxStudio_FlexVerts	= 10'000;
// total textures
static constexpr uint32_t MaxStudio_Skins		= 32;
// total bones actually used
static constexpr uint32_t MaxStudio_Bones		= 128;
// maximum number of low level flexes (actual morph targets)
static constexpr uint32_t MaxStudio_FlexDesc	= 1'024;
// maximum number of flexcontrollers (input sliders)
static constexpr uint32_t MaxStudio_FlexControl	= 96;
static constexpr uint32_t MaxStudio_PoseParam	= 24;
static constexpr uint32_t MaxStudio_BoneControl	= 4;
static constexpr uint32_t MaxStudio_AnimBlocks	= 256;
static constexpr uint32_t MaxStudio_BoneBits	= 7;
static constexpr uint32_t MaxStudio_BonePerVert = 3;

enum class StudioProc
{
	AxisInterp = 1,
	QuatInterp,
	AnimatBone,
	AnimatAttach,
	Jiggle
};

namespace StudioJiggle
{
	static constexpr uint32_t IsFlexisble			= 1 << 0;
	static constexpr uint32_t IsRigid				= 1 << 1;
	static constexpr uint32_t HasYawConstraint		= 1 << 2;
	static constexpr uint32_t HasPitchConstraint	= 1 << 3;
	static constexpr uint32_t HasAngleConstraint	= 1 << 4;
	static constexpr uint32_t HasLengthConstraint	= 1 << 5;
	static constexpr uint32_t HasBaseSpring			= 1 << 6;
	// simple squash and stretch sinusoid "boing"
	static constexpr uint32_t IsBoing				= 1 << 7;
}

namespace BoneCalcMask
{
	// bone is physically simulated when physics are active
	static constexpr uint32_t Physically_Simulated	= 1 << 0;
	// procedural when physics is active
	static constexpr uint32_t Physics_Procedural	= 1 << 1;
	// bone is always procedurally animated
	static constexpr uint32_t Always_Procedural		= 1 << 2;
	// bone aligns to the screen, not constrained in motion.
	static constexpr uint32_t Screen_AlignSphere	= 1 << 3;
	// bone aligns to the screen, constrained by it's own axis.
	static constexpr uint32_t Screen_AlignCylinder	= 1 << 4;

	static constexpr uint32_t Mask = 0x1F;
}

namespace BoneUsedMask
{
	static constexpr uint32_t Anything		= 0x7F'F00;
	// bone (or child) is used by a hit box
	static constexpr uint32_t Hitbox		= 0x00'100;
	// bone (or child) is used by an attachment point
	static constexpr uint32_t Attachement	= 0x00'200;
	// bone (or child) is used by the toplevel model via skinned vertex
	static constexpr uint32_t VertexLod0	= 0x00'400;
	static constexpr uint32_t VertexLod1	= 0x00'800;
	static constexpr uint32_t VertexLod2	= 0x01'000;
	static constexpr uint32_t VertexLod3	= 0x02'000;
	static constexpr uint32_t VertexLod4	= 0x04'000;
	static constexpr uint32_t VertexLod5	= 0x08'000;
	static constexpr uint32_t VertexLod6	= 0x10'000;
	static constexpr uint32_t VertexLod7	= 0x20'000;
	// bone is available for bone merge to occur against it
	static constexpr uint32_t BoneMerge		= 0x40'000;

	static constexpr uint32_t Mask			= Anything;
	static constexpr uint32_t VertexMask	= 0x3F'C00;

	constexpr uint32_t VertedAtLod(int lod)
	{
		return VertexLod0 << lod;
	}
	constexpr uint32_t AnythingAtLod(int lod)
	{
		return (Anything & ~Anything) | VertedAtLod(lod);
	}
}

static constexpr size_t MaxBone_Lods = 8;
static constexpr size_t BoneFixedAligment = 0x100'000;
// Vector48
static constexpr size_t BoneFlag_HasSaveFramePos = 0x200'000;
// Quaternion64
static constexpr size_t BoneFlag_HasSaveFrameRot = 0x400'000;

enum class BoneIKRule
{
	Self = 1,
	World,
	Ground,
	Release,
	Attachment,
	Unlatch
};


namespace StudioAnimFlags
{
	// Vector48
	static constexpr uint32_t RawPos	= 1 << 0;
	// Quaternion48
	static constexpr uint32_t RawRot	= 1 << 1;
	// mstudioanim_valueptr_t
	static constexpr uint32_t AnimPos	= 1 << 2;
	// mstudioanim_valueptr_t
	static constexpr uint32_t AnimRot	= 1 << 3;
	static constexpr uint32_t Delta		= 1 << 4;
	// Quaternion64
	static constexpr uint32_t RawRot2	= 1 << 5;
}


namespace StudioHDRFlags
{
	// This flag is set if no hitbox information was specified
	static constexpr uint32_t AutoGeneratedHitbox		= 0x000'001;
	// NOTE:  This flag is set at loadtime, not mdl build time so that we don't have to rebuild
	// models when we change materials.
	static constexpr uint32_t UsesEnvCubemap			= 0x000'002;
	// Use this when there are translucent parts to the model but we're not going to sort it 
	static constexpr uint32_t ForceOpaque				= 0x000'004;
	// Use this when we want to render the opaque parts during the opaque pass
	// and the translucent parts during the translucent pass
	static constexpr uint32_t TranslucentTwoPass		= 0x000'008;
	// This is set any time the .qc files has $staticprop in it
	// Means there's no bones and no transforms
	static constexpr uint32_t StaticProp				= 0x000'010;
	// NOTE:  This flag is set at loadtime, not mdl build time so that we don't have to rebuild
	// models when we change materials.
	static constexpr uint32_t UsesFBTexture				= 0x000'020;
	// This flag is set by studiomdl.exe if a separate "$shadowlod" entry was present
	//  for the .mdl (the shadow lod is the last entry in the lod list if present)
	static constexpr uint32_t HasShadowLod				= 0x000'040;
	// NOTE:  This flag is set at loadtime, not mdl build time so that we don't have to rebuild
	// models when we change materials.
	static constexpr uint32_t UsesBumpMapping			= 0x000'080;// NOTE:  This flag is set when we should use the actual materials on the shadow LOD
	// instead of overriding them with the default one (necessary for translucent shadows)
	static constexpr uint32_t UsesShadowLodMat			= 0x000'100;
	// NOTE:  This flag is set when we should use the actual materials on the shadow LOD
	// instead of overriding them with the default one (necessary for translucent shadows)
	static constexpr uint32_t Obselete					= 0x000'200;
	static constexpr uint32_t Unusued					= 0x000'400;

	// NOTE:  This flag is set at mdl build time
	static constexpr uint32_t NoForcedFade				= 0x000'800;
	// NOTE:  The npc will lengthen the viseme check to always include two phonemes
	static constexpr uint32_t PhonemeCrossFade			= 0x001'000;

	// This flag is set when the .qc has $constantdirectionallight in it
	// If set, we use constantdirectionallightdot to calculate light intensity
	// rather than the normal directional dot product
	// only valid if STUDIOHDR_FLAGS_STATIC_PROP is also set
	static constexpr uint32_t ContantDirectionLightDot	= 0x002'000;
	// Flag to mark delta flexes as already converted from disk format to memory format
	static constexpr uint32_t FlexesConverted			= 0x004'000;
	// Indicates the studiomdl was built in preview mode
	static constexpr uint32_t BuiltinPreviewMode		= 0x008'000;
	// Ambient boost (runtime flag)
	static constexpr uint32_t AmbientBoost				= 0x010'000;
	// Don't cast shadows from this model (useful on first-person models)
	static constexpr uint32_t DontCastShadows			= 0x020'000;
	// alpha textures should cast shadows in vrad on this model (ONLY prop_static!)
	static constexpr uint32_t CastTextureShadows		= 0x040'000;
	// flagged on load to indicate no animation events on this model
	static constexpr uint32_t VertAnimFixedPointScale	= 0x200'000;
}


enum class StudioFlexOperator
{
	// get float
	Const = 1,
	// get Flexcontroller value
	Fetch1,
	// get flex weight
	Fetch2,
	Add,
	Sub,
	Mul,
	Div,
	// not implemented
	Neg,
	// not implemented
	Exp,
	// only used in token parsing
	Open,
	// only used in token parsing
	Close,
	Comma,
	Max,
	Min,
	// Fetch a value from a 2 Way slider for the 1st value RemapVal( 0.0, 0.5, 0.0, 1.0 )
	TwoWay0,
	// Fetch a value from a 2 Way slider for the 2nd value RemapVal( 0.5, 1.0, 0.0, 1.0 )
	TwoWay1,
	// Fetch a value from a 2 Way slider for the 2nd value RemapVal( 0.5, 1.0, 0.0, 1.0 )
	NWay,
	// Perform a combo operation (essentially multiply the last N values on the stack)
	Combo,
	// Performs a combination domination operation
	Dominate,
	DmeLowerEyeLid,
	DmeUpperEyeLid,
};

namespace StudioMotionFlags
{
	static constexpr uint32_t X		= 0x0'001;
	static constexpr uint32_t Y		= 0x0'002;
	static constexpr uint32_t Z		= 0x0'004;
	static constexpr uint32_t XR	= 0x0'008;
	static constexpr uint32_t YR	= 0x0'010;
	static constexpr uint32_t ZR	= 0x0'020;
	static constexpr uint32_t LX	= 0x0'040;
	static constexpr uint32_t LY	= 0x0'080;
	static constexpr uint32_t LZ	= 0x0'100;
	static constexpr uint32_t LXR	= 0x0'200;
	static constexpr uint32_t LYR	= 0x0'400;
	static constexpr uint32_t LZR	= 0x0'800;
	static constexpr uint32_t Linear= 0x1'000;
}

static constexpr uint32_t StudioBoneController_Types = 0x003'FFFF;
// controller that wraps shortest distance
static constexpr uint32_t StudioBoneController_Rloop = 0x040'000;

namespace StudioSeqFlags
{
	// ending frame should be the same as the starting frame
	static constexpr uint32_t Looping	= 0x0'001;
	// do not interpolate between previous animation and this one
	static constexpr uint32_t Snap		= 0x0'002;
	// this sequence "adds" to the base sequences, not slerp blends
	static constexpr uint32_t Delta		= 0x0'004;
	// temporary flag that forces the sequence to always play
	static constexpr uint32_t AutoPlay	= 0x0'008;
	static constexpr uint32_t Post		= 0x0'010;
	// this animation/sequence has no real animation data
	static constexpr uint32_t AllZeros	= 0x0'020;
	// cycle index is taken from a pose parameter index
	static constexpr uint32_t CyclePose = 0x0'080;
	// cycle index is taken from a real-time clock, not the animations cycle index
	static constexpr uint32_t RealTime	= 0x0'100;
	// sequence has a local context sequence
	static constexpr uint32_t Local		= 0x0'200;
	// don't show in default selection views
	static constexpr uint32_t Hidden	= 0x0'400;
	// a forward declared sequence (empty)
	static constexpr uint32_t Override	= 0x0'800;
	// Has been updated at runtime to activity index
	static constexpr uint32_t Activity	= 0x1'000;
	// Has been updated at runtime to event index
	static constexpr uint32_t Event		= 0x2'000;
	// sequence blends in worldspace
	static constexpr uint32_t World		= 0x4'000;

	static constexpr uint32_t ALPost	= 0x0'010;
	// convert layer ramp in/out curve is a spline instead of linear
	static constexpr uint32_t ALSpline	= 0x0'040;
	// pre-bias the ramp curve to compense for a non-1 weight, assuming a second layer is also going to accumulate
	static constexpr uint32_t ALXFade	= 0x0'080;
	// animation always blends at 1.0 (ignores weight)
	static constexpr uint32_t ALNoBlend = 0x0'200;
	// layer is a local context sequence
	static constexpr uint32_t ALLocal	= 0x1'000;
	// layer blends using a pose parameter instead of parent cycle
	static constexpr uint32_t ALPose	= 0x4'000;
}

namespace StudioDraw
{
	static constexpr uint32_t None = 0;
	static constexpr uint32_t Render = 1 << 0;
	static constexpr uint32_t ViewXFormatAttachement = 1 << 1;
	static constexpr uint32_t DrawTranslucentSubmodels = 1 << 2;
	static constexpr uint32_t TwoPass = 1 << 3;
	static constexpr uint32_t StaticLighting = 1 << 4;
	static constexpr uint32_t WireFrame = 1 << 5;
	static constexpr uint32_t ItemBlink = 1 << 6;
	static constexpr uint32_t NoShadows = 1 << 7;
	static constexpr uint32_t WireFrame_VCollide = 1 << 8;
	static constexpr uint32_t NoOverrideForAttach = 1 << 9;
	// Not a studio flag, but used to flag when we want studio stats
	static constexpr uint32_t GenerateStats = 1 << 24;
	// Not a studio flag, but used to flag model as using shadow depth material override
	static constexpr uint32_t SSAO_DepthTexture = 1 << 27;
	// Not a studio flag, but used to flag model as using shadow depth material override
	static constexpr uint32_t Shadow_DepthTexture = 1 << 30;
	// Not a studio flag, but used to flag model as a non-sorting brush model
	static constexpr uint32_t Transparency = 1 << 31;
}


TF2_NAMESPACE_END();
